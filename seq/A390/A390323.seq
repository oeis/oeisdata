%I A390323 #27 Dec 21 2025 19:28:42
%S A390323 0,0,0,0,4,0,10,0,12,9,37,0,49,9,26,24,94,0,112,9,58,45,175,0,154,70,
%T A390323 145,76,305,0,335,97,183,130,271,60,505,165,286,129,622,25,664,171,
%U A390323 266,249,799,60,707,178,507,310,1049,109,734,299,666,461,1329,49,1389,461,642,524,1076,174,1709,538,975,285,1916,229,1988,658,795,676,1615,241,2368,495
%N A390323 Sum of composite numbers coprime to n in the range 1 < k < n.
%C A390323 The zeros of this sequence are listed in A048597, which is a finite sequence with 30 as its largest element. The proof, discovered independently by Schatunowsky and Wolfskehl, is elementary but relies on results that are not elementary, such as Bertrand's postulate.
%C A390323 However, one can get surprisingly far trying to prove it by elementary means relying only on elementary results. It is almost trivially easy to prove that a(n) is positive for any n > 30 that is not divisible by 6. In the odd case, a(n) is at least 4 + 8 + 16 = 28, and in the even case a(n) is at least 9 + 18 = 27. And if n is divisible by 6 and of the form 6p, where p is a prime greater than 5, then a(n) is at least 25. Using Bertrand's postulate seems to be a requirement for proving the theorem for primorials, near primorials and other multiples of 6 having more than three prime factors.
%H A390323 ProofWiki, <a href="https://proofwiki.org/wiki/Schatunowsky%27s_Theorem">Schatunowsky's theorem</a>
%F A390323 For odd n, a(n) >= A003817(n) - 3. The hedge "or equal to" is needed for n = 3, 5 or 9.
%e A390323 a(7) = 10 because the numbers 1 to 6 are all coprime to 7 and of those 4 and 6 are composite, they add up to 10.
%e A390323 a(8) = 0 because although 1, 3, 5 and 7 are coprime to 8, none of those numbers are composite.
%t A390323 Table[Plus@@Select[Range[2, n - 1], GCD[#, n] == 1 && Not[PrimeQ[#]] &], {n, 80}]
%o A390323 (Scala) def isPrime(num: Int): Boolean = Math.abs(num) match {
%o A390323   case 0 => false
%o A390323   case 1 => false
%o A390323   case n => (2 to Math.floor(Math.sqrt(n)).toInt) forall (p => n % p != 0)
%o A390323 }
%o A390323 def euclGCD(a: Int, b: Int): Int = b match {
%o A390323   case 0 => a
%o A390323   case n => Math.abs(euclGCD(b, a % b))
%o A390323 }
%o A390323 def addUpCompositeCoprimes(n: Int): Int = {
%o A390323   (2 to (n - 1)).filter(m => !isPrime(m) && euclGCD(m, n) == 1).sum
%o A390323 }
%o A390323 (1 to 100).map(addUpCompositeCoprimes)
%Y A390323 Cf. A000203, A001065, A036997.
%Y A390323 Cf. A325284, near primorials; A070826, half primorials.
%Y A390323 Cf. A064819, difference between the square of the smallest prime not a divisor of primorial(n) and primorial(n) itself.
%K A390323 nonn,easy,new
%O A390323 1,5
%A A390323 _Alonso del Arte_, Nov 01 2025
