%I A390129 #80 Jan 17 2026 13:19:31
%S A390129 1,2,4,6,10,16,24,38,60,92,144,226,362,570,906,1430,2272,3600,5710,
%T A390129 9072,14390,22838,36254,57562,91354,145028,230102,365296,579822,
%U A390129 920430,1460994,2319002,3681214,5843546,9276188,14724728,23373826,37103118
%N A390129 The number of layers of vertices that ever have chips in a certain chip-firing game that starts with 2^n chips and is described in the comments.
%C A390129 Consider the following chip-firing game on the integer points of the first quadrant (i.e., set of vertices (x, y) where x and y are nonnegative integers): start with 2^n chips at the origin (i.e., point (0, 0)). If a vertex (x, y) has at least 2 chips, it fires by sending one chip to (x+1, y) and one chip to (x, y+1). The vertex (x, y) loses two chips during each firing. The total number of firings in the game is finite. For each nonnegative integer i, we define layer i to be the set of all vertices that have Manhattan distance i from the origin. The term a(n) is the number of layers that ever have chips.
%C A390129 Beginning with the term at index n = 1, this sequence of integers is even.
%C A390129 Below, we have a table for the maximum number of chips at each vertex in the firing process for n=4:
%C A390129   16
%C A390129   8 8
%C A390129   4 8 4
%C A390129   2 6 6 2
%C A390129   1 4 6 4 1
%C A390129   2 5 5 2
%C A390129   1 3 4 3 1
%C A390129   1 3 3 1
%C A390129   1 2 1
%C A390129   1 1
%D A390129 Caroline Klivans, The Mathematics of Chip-Firing, CRC Press, 2019, Chapter 6.5.
%H A390129 Ryota Inagaki, Tanya Khovanova, and Austin Luo, <a href="https://arxiv.org/abs/2601.09125">Chip-firing on the Lattice of Nonnegative Integer Points</a>, arXiv:2601.09125 [math.CO], 2026. See p. 12.
%H A390129 Wikipedia, <a href="https://en.wikipedia.org/wiki/Chip-firing_game">Chip-firing game</a>.
%o A390129 (Python)
%o A390129 def generate_and_count_rows(n):
%o A390129     l1 = [2**n]
%o A390129     stab = (max(l1) < 2)
%o A390129     layer_count = 1
%o A390129     while not stab:
%o A390129         l2 = [l1[0]//2]
%o A390129         for i in range(1, len(l1)):
%o A390129             l2.append(l1[i]//2 + l1[i-1]//2)
%o A390129         l2.append(l1[len(l1)-1]//2)
%o A390129         l1 = l2
%o A390129         if (max(l1) < 2):
%o A390129             stab = True
%o A390129         if l1[0] == 0:
%o A390129             l1 = l1[1:]
%o A390129         if l1[-1] == 0:
%o A390129             l1 = l1[:len(l1)-1]
%o A390129         layer_count+= 1
%o A390129     return layer_count
%o A390129 for i in range(28):
%o A390129     print(generate_and_count_rows(i))
%Y A390129 Cf. A390355, A389565, A259013, A376131, A378726.
%K A390129 nonn,more,changed
%O A390129 0,2
%A A390129 _Ryota Inagaki_, _Tanya Khovanova_, and _Austin Luo_, Nov 28 2025
%E A390129 a(28)-a(37) from _Sean A. Irvine_, Dec 10 2025
