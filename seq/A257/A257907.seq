%I A257907 #28 Sep 11 2025 18:19:19
%S A257907 1,2,3,-2,4,-3,5,-1,7,-9,8,-4,9,-8,10,-5,15,-19,11,-10,12,-7,17,-18,
%T A257907 16,-13,19,-17,21,-16,26,-29,23,-21,25,-23,27,-26,28,-27,29,-25,33,
%U A257907 -35,31,-22,40,-45,35,-34,36,-33,39,-41,37,-31,43,-42,44,-47,41
%N A257907 After 1, the first differences of A257906 (its d-sequence).
%C A257907 This is sequence (d(n)) generated by the following generic rule, "Rule 3" (see below) with parameters a(1) = 0 and d(1) = 1, while A257906 gives the corresponding sequence a(n).
%C A257907 Rule 3 follows.  For k >= 1, let  A(k) = {a(1), …, a(k)} and D(k) = {d(1), …, d(k)}.  Begin with k = 1 and nonnegative integers a(1) and d(1).
%C A257907 Step 1:  If there is an integer h such that 1 - a(k) < h < 0 and h is not in D(k) and a(k) + h is not in A(k), let d(k+1) be the least such h, let a(k+1) = a(k) + h, replace k by k + 1, and repeat Step 1; otherwise do Step 2.
%C A257907 Step 2:  Let h be the least positive integer not in D(k) such that a(k) - h is not in A(k).  Let a(k+1) = a(k) + h and d(k+1) = h.  Replace k by k+1 and do Step 1.
%C A257907 See A257905 for a guide to related sequences and conjectures.
%C A257907 An informal version of Rule 3 follows:  the sequences "d" and "a" are jointly generated, the "driving idea" idea being that each new term of "d" is obtained by a greedy algorithm.  See A131388 for a similar procedure (Rule 1).
%H A257907 Clark Kimberling (first 1000 terms) & Antti Karttunen, <a href="/A257907/b257907.txt">Table of n, a(n) for n = 1..10000</a>
%e A257907 a(1) = 0, d(1) = 1;
%e A257907 a(2) = 2, d(2) = 2;
%e A257907 a(3) = 5, d(3) = 3;
%e A257907 a(4) = 3, d(4) = -2.
%t A257907 {a, f} = {{0}, {1}}; Do[tmp = {#, # - Last[a]} &[Min[Complement[#, Intersection[a, #]]&[Last[a] + Complement[#, Intersection[f, #]] &[Range[2 - Last[a], -1]]]]];
%t A257907 If[! IntegerQ[tmp[[1]]], tmp = {Last[a] + #, #} &[NestWhile[# + 1 &, 1, ! (! MemberQ[f, #] && ! MemberQ[a, Last[a] - #]) &]]]; AppendTo[a, tmp[[1]]]; AppendTo[f, tmp[[2]]], {120}]; {a, f} (* _Peter J. C. Moses_, May 14 2015 *)
%o A257907 (Scheme) ;; With memoization-macro definec.
%o A257907 ;; Naive quadratic algorithm, but suffices us for now. Needs also code from A257906:
%o A257907 (definec (A257907 n) (cond ((= 1 n) 1) (else (let ((k (- n 1)) (a_k (A257906 (- n 1)))) (let aloop ((h (+ 1 (- 1 a_k)))) (cond ((zero? h) (let bloop ((h 1)) (cond ((and (not_in_range_of? (- a_k h) A257906 k) (not_in_range_of? h A257907 k)) h) (else (bloop (+ 1 h)))))) ((and (not_in_range_of? (+ a_k h) A257906 k) (not_in_range_of? h A257907 k)) h) (else (aloop (+ 1 h)))))))))
%o A257907 (define (not_in_range_of? k fun upto_n) (let loop ((i 1)) (cond ((> i upto_n) #t) ((= (fun i) k) #f) (else (loop (+ i 1))))))
%o A257907 ;; _Antti Karttunen_, May 20 2015
%o A257907 (Haskell)
%o A257907 import Data.List ((\\))
%o A257907 a257907 n = a257907_list !! (n-1)
%o A257907 a257907_list = 1 : f [0] [1] where
%o A257907    f xs@(x:_) ds = g [2 - x .. -1] where
%o A257907      g [] = h : f ((x + h) : xs) (h : ds) where
%o A257907                   (h:_) = [z | z <- [1..] \\ ds, x - z `notElem` xs]
%o A257907      g (h:hs) | h `notElem` ds && y `notElem` xs = h : f (y:xs) (h:ds)
%o A257907               | otherwise = g hs
%o A257907               where y = x + h
%o A257907 -- _Reinhard Zumkeller_, Jun 03 2015
%Y A257907 After initial 1, the first differences of A257906 (the associated a-sequence for this rule).
%Y A257907 Cf. A257905.
%K A257907 sign,easy
%O A257907 1,2
%A A257907 _Clark Kimberling_, May 16 2015
