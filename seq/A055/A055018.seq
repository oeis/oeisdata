%I A055018 #34 Dec 09 2025 12:16:34
%S A055018 411,811,1421,2036,2044,2054,3054,4036,4044,4054,8036,12036,16036,
%T A055018 20036,24036,28036,32036,40011,40044,50054,50074,80011,88296,100110,
%U A055018 100270,100369,120296,120404,140021,144242,176296,200044,200270,200369
%N A055018 Numbers k such that k and k+1 are modest (cf. A054986).
%H A055018 Michael S. Branicky, <a href="/A055018/b055018.txt">Table of n, a(n) for n = 1..2000</a> (terms 1..250 from Reinhard Zumkeller)
%e A055018 2036 is modest because Mod[2036, 36] = 20. 2037 is modest because Mod[2037, 037] = 2. Hence 2036 is this pair's modest twin representative.
%t A055018 mdstQ[n_,d_]:=Module[{c},c=(FromDigits/@TakeDrop[IntegerDigits[n],d]);Mod[n,c[[2]]/.(0->1)]==c[[1]]]; SequencePosition[Table[ If[ Total[ Boole[ Table[ mdstQ[n,d],{d,IntegerLength[n]-1}]]]>0,1,0],{n,201000}],{1,1}][[;;,1]] (* _Harvey P. Dale_, Nov 22 2025 *)
%o A055018 (Haskell)
%o A055018 import Data.List (elemIndices)
%o A055018 a055018 n = a055018_list !! (n-1)
%o A055018 a055018_list = map (a054986 . (+ 1)) $ elemIndices 1 $
%o A055018                zipWith (-) (tail a054986_list) a054986_list
%o A055018 -- _Reinhard Zumkeller_, Mar 26 2012
%o A055018 (Python)
%o A055018 from itertools import count, islice
%o A055018 def modest(n):
%o A055018     pow10 = 1
%o A055018     while (t:= divmod(n, pow10))[0]:
%o A055018         if t[1] and n%t[1] == t[0]: return True
%o A055018         pow10 *= 10
%o A055018     return False
%o A055018 def agen(start=1): # generator of terms >= start
%o A055018     modestk = modest(start-1)
%o A055018     for k in count(start):
%o A055018         modestk1, modestk = modestk, modest(k)
%o A055018         if modestk and modestk1: yield k-1
%o A055018 print(list(islice(agen(), 38))) # _Michael S. Branicky_, Dec 08 2025
%Y A055018 Cf. A054986.
%K A055018 base,nonn,changed
%O A055018 1,1
%A A055018 _Hans Havermann_, May 31 2000
