%I A393569 #18 Feb 25 2026 16:52:32
%S A393569 0,0,1,1,1,1,1,1,3,1,1,1,1,1,3,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,
%T A393569 1,1,1,1,1,1,1,1,1,1,3,1,1,1,3,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,
%U A393569 3,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1
%N A393569 Number of iterations required to reach the fixed point (strictly interleaved state) in the prime-composite merging process starting from {1, 2, ..., n}.
%C A393569 The process consists of summing adjacent terms of the same primality type until no two neighbors share the same status. This sequence measures the "computational depth" of the convergence. Peaks occur when sums change their primality status and merge with existing neighbors in subsequent steps.
%C A393569 The sequence appears to take only 1 or 3 iterations to reach a fixed point (after the initial 0s).
%C A393569 a(n) <= 3 for n <= 10^6.
%e A393569 a(21) = 3 because the sequence {1, ..., 21} requires three full iterations to reach a strictly interleaved state:
%e A393569 Step 0: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]
%e A393569 Step 1 (First pass): Grouping terms of the same type (e.g., 2+3=5, 8+9+10=27, 14+15+16=45, 20+21=41).
%e A393569 Current sequence: [1, 5, 4, 5, 6, 7, 27, 11, 12, 13, 45, 17, 18, 19, 41]
%e A393569 Note: Here, 19 and 41 are both primes, and 12, 13, 45, 17 are alternating (C, P, C, P).
%e A393569 Step 2 (Second pass): Adjacent primes 19 and 41 merge (19+41=60).
%e A393569 Current sequence: [1, 5, 4, 5, 6, 7, 27, 11, 12, 13, 45, 17, 18, 60]
%e A393569 Note: Now, 18 and 60 are both composite, requiring another pass.
%e A393569 Step 3 (Third pass): Adjacent composites 18 and 60 merge (18+60=78).
%e A393569 Final sequence: [1, 5, 4, 5, 6, 7, 27, 11, 12, 13, 45, 17, 78]
%e A393569 (Types: C, P, C, P, C, P, C, P, C, P, C, P, C). Stable state reached.
%o A393569 (Python)
%o A393569 import sympy as sp
%o A393569 def a(n):
%o A393569     if n <= 1: return 0
%o A393569     seq = list(range(1, n + 1))
%o A393569     iters = 0
%o A393569     while True:
%o A393569         if all(sp.isprime(seq[i]) != sp.isprime(seq[i+1]) for i in range(len(seq)-1)):
%o A393569             break
%o A393569         new_seq = []
%o A393569         i = 0
%o A393569         while i < len(seq):
%o A393569             is_p = sp.isprime(seq[i])
%o A393569             g_sum = seq[i]
%o A393569             j = i + 1
%o A393569             while j < len(seq) and sp.isprime(seq[j]) == is_p:
%o A393569                 g_sum += seq[j]
%o A393569                 j += 1
%o A393569             new_seq.append(g_sum)
%o A393569             i = j
%o A393569         seq = new_seq
%o A393569         iters += 1
%o A393569     return iters
%o A393569 (PARI)
%o A393569 step(v)={my(L=List(),s=0,f=isprime(v[1])); foreach(v, t, if(f!=isprime(t), f=!f; listput(L,s); s=0); s+=t); listput(L,s); Vec(L)}
%o A393569 a(n)={my(v=[1..n], c=-1, t=0); while(#v!=t, c++; t=#v; v=step(v)); c} \\ _Andrew Howroyd_, Feb 21 2026
%Y A393569 The resulting final states for each n are given in A393568.
%K A393569 nonn,new
%O A393569 1,9
%A A393569 _Maximiliano NicolÃ¡s Cardich_, Feb 21 2026
